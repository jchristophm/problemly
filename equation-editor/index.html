<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>MiniMathEditor</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
  <style>
    body {
      font-family: sans-serif;
      background: #f7f7f7;
      padding: 2rem;
      display: flex;
      justify-content: center;
    }
    .editor-container {
      background: white;
      border-radius: 10px;
      padding: 1rem;
      box-shadow: 0 0 15px rgba(0,0,0,0.1);
      width: 100%;
      max-width: 600px;
      position: relative;
    }
    #renderedField {
      min-height: 60px;
      font-size: 1.25rem;
      padding: 0.75rem;
      border: 1px solid #ccc;
      border-radius: 6px;
      background: #fff;
      outline: none;
      white-space: nowrap;
    }
    #ghostInput {
      position: absolute;
      opacity: 0;
      pointer-events: none;
    }
  </style>
</head>
<body>
  <div class="editor-container">
    <h2>MiniMathEditor</h2>
    <div id="renderedField" tabindex="0"></div>
    <input id="ghostInput" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false">
  </div>

  <script>
    const renderedField = document.getElementById('renderedField');
    const ghostInput = document.getElementById('ghostInput');

    let tokens = [];
    let caretPath = [0];

    function resolvePath(path) {
      let ref = tokens;
      for (let i = 0; i < path.length - 1; i++) {
        ref = ref[path[i]];
      }
      return { ref, index: path[path.length - 1] };
    }

    function tokenToLatex(token) {
      if (!token) return '';
      switch (token.type) {
        case 'frac':
          return `\\frac{${(token.left || []).map(tokenToLatex).join('')}}{${(token.right || []).map(tokenToLatex).join('')}}`;
        case 'sup':
          return `${(token.base || []).map(tokenToLatex).join('')}^{${(token.exponent || []).map(tokenToLatex).join('')}}`;
        case 'sub':
          return `${(token.base || []).map(tokenToLatex).join('')}_{${(token.sub || []).map(tokenToLatex).join('')}}`;
        case 'group':
          return `\\left(${(token.tokens || []).map(tokenToLatex).join('')}\\right)`;
        case 'caret':
          return '\\textcolor{gray}{|}';
        case 'char':
        default:
          return token.latex || '';
      }
    }

    function renderTokensWithCaret(tokens, path) {
      const deepCopy = JSON.parse(JSON.stringify(tokens));
      let ref = deepCopy;
      for (let i = 0; i < path.length - 1; i++) {
        ref = ref[path[i]];
      }
      ref.splice(path[path.length - 1], 0, { type: 'caret' });
      return deepCopy;
    }

    function render() {
      if (tokens.length === 0) {
        katex.render('\\textcolor{gray}{Start typing...}', renderedField, { throwOnError: false });
        return;
      }
      const withCaret = renderTokensWithCaret(tokens, caretPath);
      const latex = withCaret.map(tokenToLatex).join('');
      try {
        katex.render(latex, renderedField, { throwOnError: false });
      } catch {
        renderedField.innerHTML = '<span style="color:red">[Invalid Expression]</span>';
      }
    }

    function insertChar(char) {
      const { ref, index } = resolvePath(caretPath);

      if (char === '^') {
        const base = ref.splice(index - 1, 1);
        const sup = { type: 'sup', base, exponent: [] };
        ref.splice(index - 1, 0, sup);
        caretPath = caretPath.slice(0, -1).concat(index - 1, 'exponent', 0);
        render(); return;
      }

      if (char === '_') {
        const base = ref.splice(index - 1, 1);
        const sub = { type: 'sub', base, sub: [] };
        ref.splice(index - 1, 0, sub);
        caretPath = caretPath.slice(0, -1).concat(index - 1, 'sub', 0);
        render(); return;
      }

      if (char === '/') {
        const left = ref.splice(index - 1, 1);
        const frac = { type: 'frac', left, right: [] };
        ref.splice(index - 1, 0, frac);
        caretPath = caretPath.slice(0, -1).concat(index - 1, 'right', 0);
        render(); return;
      }

      if (char === '(') {
        const group = { type: 'group', tokens: [] };
        ref.splice(index, 0, group);
        caretPath = caretPath.slice(0, -1).concat(index, 'tokens', 0);
        render(); return;
      }

      if (char === ')') {
        const groupIndex = caretPath.lastIndexOf('tokens');
        if (groupIndex !== -1) {
          caretPath = caretPath.slice(0, groupIndex).concat(caretPath[groupIndex - 1] + 1);
          render(); return;
        }
      }

      ref.splice(index, 0, { type: 'char', latex: char });
      caretPath[caretPath.length - 1]++;
      render();
    }

    function deleteChar() {
      const { ref, index } = resolvePath(caretPath);
      if (index > 0) {
        ref.splice(index - 1, 1);
        caretPath[caretPath.length - 1]--;
        render();
      }
    }

function diveIntoStructure(token, path, dir) {
  if (!token) return null;

  const fields = {
    frac: dir < 0 ? ['right', 'left'] : ['left', 'right'],
    sup: ['exponent'],
    sub: ['sub'],
    group: ['tokens']
  };

  const keys = fields[token.type];
  if (keys) {
    for (const key of keys) {
      if (Array.isArray(token[key])) {
        const target = token[key];
        return path.concat(key, dir < 0 ? target.length : 0);
      }
    }
  }
  return null;
}

function moveCaret(dir) {
  let path = [...caretPath];
  const { ref, index } = resolvePath(path);

  // 1. Dive into structured token if nearby
  const diveIdx = dir > 0 ? index : index - 1;
  const diveToken = ref[diveIdx];
  const divePath = diveIntoStructure(diveToken, path.slice(0, -1).concat(diveIdx), dir);
  if (divePath) {
    caretPath = divePath;
    render();
    return;
  }

  // 2. Move normally within current array
  const newIndex = index + dir;
  if (newIndex >= 0 && newIndex <= ref.length) {
    caretPath = path.slice(0, -1).concat(newIndex);
    render();
    return;
  }

  // 3. Exit current structure (if at beginning or end)
  for (let i = path.length - 2; i >= 0; i -= 2) {
    const parentPath = path.slice(0, i);
    const { ref: pRef, index: pIdx } = resolvePath(parentPath);
    const fieldKey = path[i];  // e.g., 'left', 'right', etc.

    // Only climb out if at start or end of this array
    if ((dir < 0 && index === 0) || (dir > 0 && index === ref.length)) {
      caretPath = parentPath.slice(0, -1).concat(pIdx + dir);
      render();
      return;
    }
  }
}

    renderedField.addEventListener('click', () => ghostInput.focus());
    ghostInput.addEventListener('input', e => {
      const val = ghostInput.value;
      ghostInput.value = '';
      if (val) insertChar(val);
    });
    ghostInput.addEventListener('keydown', e => {
      if (e.key === 'Backspace') {
        e.preventDefault(); deleteChar();
      } else if (e.key === 'ArrowLeft') {
        e.preventDefault(); moveCaret(-1);
      } else if (e.key === 'ArrowRight' || e.key === ' ') {
        e.preventDefault(); moveCaret(1);
      }
    });
    renderedField.addEventListener('focus', () => ghostInput.focus());

    render();
  </script>
</body>
</html>

