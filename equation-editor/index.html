<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Smart Math Editor</title>
  <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
  <style>
    body {
      font-family: sans-serif;
      padding: 40px;
    }

    #input {
      width: 100%;
      font-size: 1.2rem;
      padding: 10px;
      border: 1px solid #ccc;
      border-radius: 6px;
    }

    #render {
      margin-top: 20px;
      padding: 12px;
      background: #f9f9f9;
      border: 1px solid #ccc;
      min-height: 50px;
      font-size: 1.4rem;
    }

    .token {
      padding: 2px 4px;
    }

    .token.active {
      background: #d0ebff;
      border-radius: 4px;
    }

    .token.sub { vertical-align: sub; font-size: 0.8em; }
    .token.sup { vertical-align: super; font-size: 0.8em; }

    .structure {
      display: inline-flex;
      align-items: center;
    }

    .structure .left,
    .structure .right {
      margin: 0 2px;
      display: inline-flex;
    }

    .parens {
      padding: 0 2px;
    }
  </style>
</head>
<body>

  <input id="input" placeholder="Type math like 1/2 or x^2" />
  <div id="render"></div>

  <script>
    const input = document.getElementById("input");
    const render = document.getElementById("render");

    let caret = { path: [0] };

    function tokenize(str) {
      const tokens = [];
      let i = 0;

      while (i < str.length) {
        const c = str[i];

        if (c === "^" && i < str.length - 1) {
          tokens.push({ type: "sup", tokens: [{ type: "text", value: str[++i] }] });
        } else if (c === "_" && i < str.length - 1) {
          tokens.push({ type: "sub", tokens: [{ type: "text", value: str[++i] }] });
        } else if (c === "/" && tokens.length > 0 && i < str.length - 1) {
          const left = tokens.pop();
          const right = { type: "text", value: str[++i] };
          tokens.push({ type: "frac", left, right });
        } else if (c === "(") {
          tokens.push({ type: "paren", tokens: [] });
        } else if (c === ")") {
          // assume balanced, close current
          // (we're not doing nesting validation here)
        } else {
          tokens.push({ type: "text", value: c });
        }

        i++;
      }

      return tokens;
    }

    function renderTokens(tokens, path = []) {
      return tokens.map((t, i) => {
        const p = path.concat(i);
        const isActive = JSON.stringify(p) === JSON.stringify(caret.path);
        const className = "token" + (isActive ? " active" : "");

        if (t.type === "text") {
          return `<span class="${className}">${t.value}</span>`;
        } else if (t.type === "sup" || t.type === "sub") {
          return `<span class="token ${t.type}">${renderTokens(t.tokens, p.concat('tokens')).join('')}</span>`;
        } else if (t.type === "frac") {
          return `<span class="structure frac">
            <span class="left">${renderTokens([t.left], p.concat('left')).join('')}</span>
            <span>/</span>
            <span class="right">${renderTokens([t.right], p.concat('right')).join('')}</span>
          </span>`;
        } else if (t.type === "paren") {
          return `<span class="structure parens">( ${renderTokens(t.tokens, p.concat('tokens')).join('')} )</span>`;
        }

        return "";
      }).join("");
    }

    function getToken(tokens, path) {
      let ref = tokens;
      for (let i = 0; i < path.length - 1; i++) {
        ref = ref[path[i]];
      }
      return ref[path[path.length - 1]];
    }

    function moveCaret(dir) {
      const flatIdx = dir < 0 ? caret.path[0] - 1 : caret.path[0];
      const t = tokens[flatIdx];

      const dive = diveIntoStructure(t, [flatIdx], dir);
      if (dive) {
        caret.path = dive;
      } else {
        caret.path[0] = Math.max(0, Math.min(tokens.length - 1, caret.path[0] + dir));
      }
      update();
    }

    function diveIntoStructure(token, path, dir) {
      if (!token) return null;

      const fields = {
        frac: dir < 0 ? "left" : "right",
        sup: "tokens",
        sub: "tokens",
        paren: "tokens"
      };

      const field = fields[token.type];
      if (!field || !token[field]) return null;

      const inner = token[field];
      if (Array.isArray(inner)) {
        return path.concat(field, 0);
      } else {
        return path.concat(field);
      }
    }

    function update() {
      render.innerHTML = renderTokens(tokens);
    }

    let tokens = tokenize("");

    input.addEventListener("input", () => {
      tokens = tokenize(input.value);
      caret = { path: [tokens.length - 1] };
      update();
    });

    input.addEventListener("keydown", e => {
      if (e.key === "ArrowLeft") {
        moveCaret(-1);
        e.preventDefault();
      } else if (e.key === "ArrowRight") {
        moveCaret(1);
        e.preventDefault();
      }
    });

    input.value = "";
    tokens = tokenize("");
    update();
  </script>
</body>
</html>

