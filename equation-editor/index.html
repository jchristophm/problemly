<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>MiniMathEditor v5</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
  <style>
    body {
      font-family: sans-serif;
      background: #f7f7f7;
      padding: 2rem;
      display: flex;
      justify-content: center;
    }
    .editor-container {
      background: white;
      border-radius: 10px;
      padding: 1rem;
      box-shadow: 0 0 15px rgba(0,0,0,0.1);
      width: 100%;
      max-width: 600px;
      position: relative;
    }
    #renderedField {
      min-height: 60px;
      font-size: 1.25rem;
      padding: 0.75rem;
      border: 1px solid #ccc;
      border-radius: 6px;
      background: #fff;
      outline: none;
      white-space: nowrap;
    }
    #ghostInput {
      position: absolute;
      opacity: 0;
      pointer-events: none;
    }
  </style>
</head>
<body>
  <div class="editor-container">
    <h2>MiniMathEditor</h2>
    <div id="renderedField" tabindex="0"></div>
    <input id="ghostInput" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false">
  </div>

  <script>
    const renderedField = document.getElementById('renderedField');
    const ghostInput = document.getElementById('ghostInput');

    let tokens = [];
    let caretPath = []; // e.g., [2, 'right', 1]

    function setCaret(path) {
      caretPath = path;
    }

    function insertAtPath(tokens, path, char) {
      let ref = tokens;
      for (let i = 0; i < path.length - 1; i++) {
        ref = ref[path[i]];
      }
      const idx = path[path.length - 1];
      ref.splice(idx, 0, char);
    }

    function renderTokensWithCaret(tokens, path) {
      const deepCopy = JSON.parse(JSON.stringify(tokens));
      let ref = deepCopy;
      for (let i = 0; i < path.length - 1; i++) {
        ref = ref[path[i]];
      }
      ref.splice(path[path.length - 1], 0, { type: 'caret' });
      return deepCopy;
    }

    function tokenToLatex(token) {
      if (!token) return '';
      switch (token.type) {
        case 'frac':
          return `\\frac{${(token.left || []).map(tokenToLatex).join('') || '{}'}}{${(token.right || []).map(tokenToLatex).join('') || '{}'}}`;
        case 'sup':
          return `${(token.base || []).map(tokenToLatex).join('') || '{}'}^{${(token.exponent || []).map(tokenToLatex).join('') || '{}'}}`;
        case 'sub':
          return `${(token.base || []).map(tokenToLatex).join('') || '{}'}_{${(token.sub || []).map(tokenToLatex).join('') || '{}'}}`;
        case 'group':
          return `\\left(${(token.tokens || []).map(tokenToLatex).join('')}\\right)`;
        case 'caret':
          return '\\textcolor{gray}{|}';
        case 'char':
        default:
          return token.latex || '';
      }
    }

    function render() {
      if (tokens.length === 0) {
        katex.render('\\textcolor{gray}{Start typing...}', renderedField, { throwOnError: false });
        return;
      }
      const withCaret = renderTokensWithCaret(tokens, caretPath);
      const latex = withCaret.map(tokenToLatex).join('');
      try {
        katex.render(latex, renderedField, { throwOnError: false });
      } catch (e) {
        renderedField.innerHTML = '<span style="color:red">[Invalid Expression]</span>';
      }
    }

    function insertChar(char) {
      if (char === '^') {
        const base = tokens.splice(Math.max(0, caretPath[0] - 1), 1);
        const sup = { type: 'sup', base: base, exponent: [] };
        tokens.splice(Math.max(0, caretPath[0] - 1), 0, sup);
        setCaret([caretPath[0] - 1, 'exponent', 0]);
        render();
        return;
      }

      if (char === '_') {
        const base = tokens.splice(Math.max(0, caretPath[0] - 1), 1);
        const sub = { type: 'sub', base: base, sub: [] };
        tokens.splice(Math.max(0, caretPath[0] - 1), 0, sub);
        setCaret([caretPath[0] - 1, 'sub', 0]);
        render();
        return;
      }

      if (char === '/') {
        const left = tokens.splice(Math.max(0, caretPath[0] - 1), 1);
        const frac = { type: 'frac', left: left, right: [] };
        tokens.splice(Math.max(0, caretPath[0] - 1), 0, frac);
        setCaret([caretPath[0] - 1, 'right', 0]);
        render();
        return;
      }

      if (char === '(') {
        const group = { type: 'group', tokens: [] };
        tokens.splice(caretPath[0], 0, group);
        setCaret([caretPath[0], 'tokens', 0]);
        render();
        return;
      }

      if (char === ')') {
        setCaret([tokens.length, 0]);
        render();
        return;
      }

      insertAtPath(tokens, caretPath, { type: 'char', latex: char });
      caretPath[caretPath.length - 1]++;
      render();
    }

    function deleteChar() {
      let ref = tokens;
      for (let i = 0; i < caretPath.length - 1; i++) ref = ref[caretPath[i]];
      const idx = caretPath[caretPath.length - 1];
      if (idx > 0) {
        ref.splice(idx - 1, 1);
        caretPath[caretPath.length - 1]--;
        render();
      }
    }

    function moveCaret(dir) {
      caretPath[caretPath.length - 1] += dir;
      render();
    }

    renderedField.addEventListener('click', () => ghostInput.focus());

    ghostInput.addEventListener('input', (e) => {
      const val = ghostInput.value;
      ghostInput.value = '';
      if (val) insertChar(val);
    });

    ghostInput.addEventListener('keydown', (e) => {
      if (e.key === 'Backspace') {
        e.preventDefault();
        deleteChar();
      } else if (e.key === 'ArrowLeft') {
        e.preventDefault();
        moveCaret(-1);
      } else if (e.key === 'ArrowRight') {
        e.preventDefault();
        moveCaret(1);
      }
    });

    renderedField.addEventListener('focus', () => ghostInput.focus());
    setCaret([0]);
    render();
  </script>
</body>
</html>

