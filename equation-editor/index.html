<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>MiniMathEditor v4</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
  <style>
    body {
      font-family: sans-serif;
      background: #f7f7f7;
      padding: 2rem;
      display: flex;
      justify-content: center;
    }
    .editor-container {
      background: white;
      border-radius: 10px;
      padding: 1rem;
      box-shadow: 0 0 15px rgba(0,0,0,0.1);
      width: 100%;
      max-width: 600px;
      position: relative;
    }
    #renderedField {
      min-height: 60px;
      font-size: 1.25rem;
      padding: 0.75rem;
      border: 1px solid #ccc;
      border-radius: 6px;
      background: #fff;
      outline: none;
      white-space: nowrap;
    }
    #ghostInput {
      position: absolute;
      opacity: 0;
      pointer-events: none;
    }
    .caret {
      display: inline-block;
      width: 1px;
      background: black;
      height: 1.2em;
      vertical-align: -0.2em;
      animation: blink 1s step-end infinite;
    }
    @keyframes blink {
      50% { background: transparent; }
    }
  </style>
</head>
<body>
  <div class="editor-container">
    <h2>MiniMathEditor</h2>
    <div id="renderedField" tabindex="0"></div>
    <input id="ghostInput" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false">
  </div>

  <script>
    const renderedField = document.getElementById('renderedField');
    const ghostInput = document.getElementById('ghostInput');
    let tokens = [];
    let caretIndex = 0;

    function tokenToLatex(token) {
      if (token.type === 'frac') {
        const left = token.left.map(tokenToLatex).join('') || '{}';
        const right = token.right.map(tokenToLatex).join('') || '{}';
        return `\\frac{${left}}{${right}}`;
      } else if (token.type === 'sup') {
        const base = token.base.map(tokenToLatex).join('') || '{}';
        const exponent = token.exponent.map(tokenToLatex).join('') || '{}';
        return `${base}^{${exponent}}`;
      } else if (token.type === 'sub') {
        const base = token.base.map(tokenToLatex).join('') || '{}';
        const sub = token.sub.map(tokenToLatex).join('') || '{}';
        return `${base}_{${sub}}`;
      } else if (token.type === 'caret') {
        return '\\textcolor{gray}{|}';
      } else {
        return token.latex;
      }
    }

    function renderTokens() {
      if (tokens.length === 0) {
        katex.render('\\textcolor{gray}{Start typing...}', renderedField, { throwOnError: false });
        return;
      }

      const tokensWithCaret = [...tokens];
      tokensWithCaret.splice(caretIndex, 0, { type: 'caret' });

      try {
        const latex = tokensWithCaret.map(tokenToLatex).join('');
        katex.render(latex, renderedField, { throwOnError: false });
      } catch (err) {
        renderedField.innerHTML = '<span style="color:red">[Invalid Expression]</span>';
      }
    }

    function insertChar(char) {
      let token;

      if (char === '^') {
        const base = tokens.splice(Math.max(0, caretIndex - 1), 1);
        token = { type: 'sup', base: base, exponent: [] };
        tokens.splice(caretIndex - 1, 0, token);
        caretIndex = caretIndex;
        renderTokens();
        return;
      }

      if (char === '_') {
        const base = tokens.splice(Math.max(0, caretIndex - 1), 1);
        token = { type: 'sub', base: base, sub: [] };
        tokens.splice(caretIndex - 1, 0, token);
        caretIndex = caretIndex;
        renderTokens();
        return;
      }

      if (char === '/') {
        const left = tokens.splice(Math.max(0, caretIndex - 1), 1);
        token = { type: 'frac', left: left, right: [] };
        tokens.splice(caretIndex - 1, 0, token);
        caretIndex = caretIndex;
        renderTokens();
        return;
      }

      // insert into current nested structure if needed
      const current = tokens[caretIndex - 1];
      if (current && (current.type === 'sup' || current.type === 'frac' || current.type === 'sub')) {
        const target = current.type === 'sup' ? current.exponent : current.type === 'frac' ? current.right : current.sub;
        target.push({ type: 'char', latex: char });
        caretIndex++;
        renderTokens();
        return;
      }

      token = { type: 'char', latex: char };
      tokens.splice(caretIndex, 0, token);
      caretIndex++;
      renderTokens();
    }

    function deleteChar() {
      if (caretIndex > 0) {
        tokens.splice(caretIndex - 1, 1);
        caretIndex--;
        renderTokens();
      }
    }

    function moveCaret(dir) {
      caretIndex += dir;
      if (caretIndex < 0) caretIndex = 0;
      if (caretIndex > tokens.length) caretIndex = tokens.length;
      renderTokens();
    }

    renderedField.addEventListener('click', () => ghostInput.focus());

    ghostInput.addEventListener('input', (e) => {
      const val = ghostInput.value;
      ghostInput.value = '';
      if (val) insertChar(val);
    });

    ghostInput.addEventListener('keydown', (e) => {
      if (e.key === 'Backspace') {
        e.preventDefault();
        deleteChar();
      } else if (e.key === 'ArrowLeft') {
        e.preventDefault();
        moveCaret(-1);
      } else if (e.key === 'ArrowRight') {
        e.preventDefault();
        moveCaret(1);
      }
    });

    renderedField.addEventListener('focus', () => ghostInput.focus());
    renderTokens();
  </script>
</body>
</html>

